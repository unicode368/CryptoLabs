# Human-like password
## Part 1

Для кожного з випадків, де задана ймовірність, генерується ймовірність у заданих межах за допомогою класу Random: 
- дуже рандомні паролі - 0.01-0.05;
- топ 100 паролів - 0.05-0.1;
- топ 1М паролів - 0.5-0.9.
Далі генерується double-число, після чого відбувається порівнння зі значеннями ймовірностей: якщо отримане число менше 
ймовірності дуже рандомного пароля - генерується дуже ранжомний пароль; якщо згенероване число більше попередньої ймовірності,
але менше ймовірності топ 100 паролів - випадковим чином обирається пароль з файлу "top100Passwords.txt", і так далі.
Якщо згенероване випадковим чином число більше за всі дані значення ймовірностей - генерується пароль, який могла б вигадати
людина, і який складається з власної назви, прикметника та іменника, які обираються із заданих масивів рядків випадковим чином.
Для кожної схеми було згенеровано 100 тисяч паролів.
### Хешування
Для хешування паролів було використано схеми md5 (слабкий хеш), sha1+salt та bcrypt.
Хешування md5 відбувається за допомогою MessageDigest-об'єкту, що належить до java.security.
Спочатку створюється екземпляр MessageDigest відповідно до обраного алгоритму, після чого відбувається digest об'єкту,
а саме хешування рядка. Отримане значення зберігається в об'єкті BigInteger для подальшої конвертації в hex.
У результаті маємо хеш паролю за алгоритмом md5.

Хешування sha1 має аналогічну реалізацію, однак тут застосовується сіль довжиною 20 байт, 
яка генерується випадковим чином за допомогою методів класу SecureRandom, що також належить до java.security.
Згенерована сіль запобігає dictionary attack, однак є інші методи атак, які в порівнянні є ефективними відносно sha1,
тому ні md5, ні sha1 не рекомендовані для використання.

Найбільш надійним алгоритмом є Bcrypt. Bcrypt генерує сіль, для генерації якої може застосовуватись n-на кількість ітерацій,
і чим більша к-сть таких ітерацій, тим нижча ймовірність дістати пароль, однак час виконання алгоритму також значно зростає.
Для хешування паролю було використано методи класу Bcrypt <i>hashpw()</i> та <i>gensalt()</i> .

## Part 2
Слабкий хеш (md5) було взято з https://t.me/c/1664103404/1644.
Для взлому паролів було застосовано утиліту hashcat (https://executeatwill.com/2019/02/11/Install-hashcat-on-windows/).
Команда для взлому паролів через brute-force: hashcat64.exe -a 3 -m 0 --force weak.csv

Результати роботи:

![bruteforce result](https://github.com/unicode368/CryptoLabs/blob/main/src/main/java/lab4/Capture.PNG)

Приблизно за 30 хвилин зі 65226 паролів було отримано 32657.
Далі застосуємо dictionary-метод: hashcat64.exe -a 0 -m 0 --force weak.csv 10-million-password-list-top-1000000.txt

Результати роботи:

![dictionary result](https://github.com/unicode368/CryptoLabs/blob/main/src/main/java/lab4/Capture2.PNG)

Dictionary-пошук впорався менше, ніж за 3 хвилини, і з 65226 паролів було знайдено 55390.

### Bcrypt crack
Тепер взламаємо файл з сильним хешем - hashcat64.exe -m 3200 -a 3 -O --force strong.csv.
Посилання на сильний хеш - https://t.me/c/1664103404/1144.

Результати роботи:

![bruteforce strong](https://github.com/unicode368/CryptoLabs/blob/main/src/main/java/lab4/Capture3.PNG)

За півгодини із 100 тисяч паролів не було відновлено жодного.

Обробимо файл за допомогою dictionary-методу: hashcat64.exe -m 3200 -a 0 -O --force strong.csv 10-million-password-list-top-1000000.txt

Результати роботи:

![dictionary strong](https://github.com/unicode368/CryptoLabs/blob/main/src/main/java/lab4/Capture4.PNG)

Другий метод також не дав ніякого результату.
Це обумовлюється тим, що при bcrypt-хешуванні застосовується довільна к-сть ітерацій, і кожна ітерація значно збільшує час,
за який можна відновити пароль. Утиліта hashcat також здатна підрахувати приблизний час, за який буде відновлено паролі.
Можна бачити, що time estimated становить 269 років 184 дні, тобто на відновлення принаймні одного паролю може знадобитись
більше, ніж 1 день.
## Рекомендації
- для хешування найкраще використовувати алгоритм bcrypt з максимально великим можливим значенням cost factor, який значно
збільшує час взлому паролю, але при цьому треба також враховувати можливості своєї системи;
- пароль користувача має бути довшим за 8 символів, а також містити цифри та символи всередині паролю;
- для створення надійного паролю також можна використовувати власні назви, малопоширені слова, що завадить/значно сповільнить
пошук паролю dictionary-методом.  
 


 
 
